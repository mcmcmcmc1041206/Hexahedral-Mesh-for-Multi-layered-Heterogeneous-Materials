#pragma once
#include"tree_class.h"
#include"Voxel.h"
#include"HexActor.h"

/*
获取初始网格
可获取 带锯齿状边界初始网格
或无边界的均匀/非均匀核心网格
对应论文中3.1内容（金）
*/


class OcTree
{
public:
	OcTree(My_Voxel& _vox, unsigned int max_lenth, unsigned int min_lenth);
	~OcTree();

	//========================================================================
	// 函数功能： 综合调用函数，最终获得划分大小最多相差1的含有悬挂节点的网格
	// 使用参数： root：当前空间节点；	dst：二值化后的图像；	axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   无返回值
	// 编辑日期： 2020/3/17
	//========================================================================
	void build_adaptive_tree();

	



private:
	//========================================================================
// 函数功能： 创建一个四叉树节点，节点空间为六面体
// 使用参数： x,y ：节点左上角坐标（opencv坐标系）；	lenth：节点空间正方形边长	
//  dst： 二值化后的图像；	location：当前节点在父节点中的位置；	axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
// 返回值：   返回创建的新节点
// 编辑日期： 2020/3/17
//========================================================================
	OcTreeNode* creat_node(unsigned x, unsigned y, unsigned z, unsigned lenth, string location);

	//========================================================================
	// 函数功能： 递归的划分空间和创建节点，节点空间为正方形
	// 使用参数： root：当前空间节点；	dst：二值化后的图像；	axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   返回创建的新节点
	// 编辑日期： 2020/3/17
	//========================================================================
	void build_tree();

	//========================================================================
	// 函数功能： 判定相邻空间节点是否满足划分条件
	// 使用参数： root：当前空间节点；		axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   返回的bool以判断是否还需要继续划分当前节点
	// 编辑日期： 2020/3/17
	//========================================================================
	bool check_edge(OcTreeNode* root);

	//========================================================================
	// 函数功能： 递归划分输入的节点空间，保证相邻空间划分度相差1
	// 使用参数： root：当前空间节点；		axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   无返回值
	// 编辑日期： 2020/3/17
	//========================================================================
	void adapted_hexahedral(OcTreeNode* root);


	//========================================================================
	// 函数功能： 创建一个四叉树节点，节点空间为正方形
	// 使用参数： x,y ：节点左上角坐标（opencv坐标系）；	lenth：节点空间正方形边长	
	//  dst： 二值化后的图像；	location：当前节点在父节点中的位置；	axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   返回创建的新节点
	// 编辑日期： 2020/3/17
	//========================================================================
	OcTreeNode* creat_full_node(unsigned x, unsigned y, unsigned z, unsigned lenth, string location);


	//========================================================================
	// 函数功能： 划分满节点，既是当前空间全部充满
	// 使用参数： root：当前空间节点；		axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   无返回值
	// 编辑日期： 2020/3/17
	//========================================================================
	void build_full_node(OcTreeNode* root);

	//========================================================================
	// 函数功能： 利用广度优先算法，从最深层向上递归划分
	// 使用参数： last：上一层递归所得的非空节点；		axis：空间坐标矩阵，用于记录与判定节点空间的划分情况
	// 返回值：   无返回值
	// 编辑日期： 2020/3/17
	//========================================================================
	void layer_traversal(vector<OcTreeNode*>* last);

	//========================================================================
	// 函数功能： 取出所有叶子节点，构建表示模型的六面体单元
	// 使用参数： src ：图像
	// 返回值：   返回无符号整数
	// 编辑日期： 2020/3/17
	//========================================================================
	void get_leaf_node(OcTreeNode* root);

	//========================================================================
	// 函数功能： 计算最小的 大于图像长宽最大值的 2的指数级正整数
	// 使用参数： src ：图像
	// 返回值：   返回无符号整数
	// 编辑日期： 2020/3/17
	//========================================================================
	unsigned int get_max_hex();


	//处理跨材料的网格，将这样的网格进行再划分
	void m_subdivision(vector<Hexahedral3D*>& nodes, My_Voxel vox);

	//把对应网格按照属性加入到容器中，方便转化为txt进行输出
	void Addnodes(int index,Hexahedral3D* m_node);

public:
	OcTreeNode* root;
	vector<vector<vector<bool>>>axis;
	////将vector<OcTreeNode*>换成vector<hexahedral*>
	//vector<OcTreeNode*> nodes;//改前
	vector<Hexahedral3D*> nodes; //存放六面体

	//根据有几种材料的创建几个数组，方便后续输出为txt
	vector<Hexahedral3D*> m_node1;
	vector<Hexahedral3D*> m_node2;
	vector<Hexahedral3D*> m_node3;
private:
	My_Voxel& vox;
	//Mat& dst;
	//Mat& src;
	unsigned int max_lenth; //网格的最大值
	unsigned int min_lenth; //网格的最小值
	//若网格的最大值和最小值一样，则说明划分的是均匀网格
};
